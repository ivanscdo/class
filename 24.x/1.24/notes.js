// 2:40
// data structures
// concepts appear in coding interviews
// inherite large code-bases to "optiize" code efficiency
// computational chanllenges force one to deepen undersanding - force you to criticalling think; biggest challenge: problem solving, getting from a to b
// focus will be on terminology and concepts, not nitty-gritty
// can always ask questions in interviews
// learning javascript data structures and algorithms by loian groner
// data structures & algorithms with javascript by oreilly

// 8:38
// efficiency - number of steps
// O n complexcity is still good
// holy grail is Olog n
// ~12:45
// time complexity - rate at which algorithm slows as input grows 

// 13:48 
// big o notation 
// 2 nested for loops ~ O(n^2)
// 3 nested for loops ~ O(n^3)
// want to keep loops as shallow as possible

// Ologn - if we can throw away half of n each time
// some 

// 24:00
// memory

// 30:00
// arrays
// in other languages, arrays are limited to set length and set type

// ~33:xx
// stacks & queues
// stacks are LIFO, last-in-first-out, literally a stack of whatever
// queue
// oposite of stack, FIFO, think of as a line (UK line), 

// 37:37
// linked lists
// two props: head and tail
// elements spread out, each element/node only knows about the next
// optimization is secondary to actually getting the feature done

// ~50:xx
// review of concepts

// ~52:xx
// dictionaries
// ruby:hash, java:struct, 

// >59:xx
// missed due to call

